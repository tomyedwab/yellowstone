package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

// TypeDefinition represents a type definition from the YAML schema
type TypeDefinition struct {
	Description string                        `yaml:"description"`
	Properties  map[string]PropertyDefinition `yaml:"properties"`
}

// PropertyDefinition represents a property within a type
type PropertyDefinition struct {
	Type        string `yaml:"type"`
	ItemType    string `yaml:"itemType"`
	Nullable    bool   `yaml:"nullable"`
	Description string `yaml:"description"`
}

// RouteParameter represents a parameter for a route
type RouteParameter struct {
	Name        string `yaml:"name"`
	Type        string `yaml:"type"`
	Required    bool   `yaml:"required"`
	Description string `yaml:"description"`
}

// RouteDefinition represents an API route definition
type RouteDefinition struct {
	Route       string           `yaml:"route"`
	Description string           `yaml:"description"`
	Method      string           `yaml:"method"`
	Parameters  []RouteParameter `yaml:"parameters"`
	Returns     string           `yaml:"returns"`
}

// Schema represents the root schema structure
type Schema struct {
	Types  map[string]TypeDefinition `yaml:"types"`
	Events map[string]TypeDefinition `yaml:"events"`
	Routes []RouteDefinition         `yaml:"routes"`
}

func main() {
	if len(os.Args) != 3 {
		fmt.Fprintf(os.Stderr, "Usage: %s <input_yaml> <output_kotlin>\n", os.Args[0])
		os.Exit(1)
	}

	inputFile := os.Args[1]
	outputFile := os.Args[2]

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	// Load YAML schema
	yamlData, err := os.ReadFile(inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading YAML file: %v\n", err)
		os.Exit(1)
	}

	var schema Schema
	if err := yaml.Unmarshal(yamlData, &schema); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing YAML: %v\n", err)
		os.Exit(1)
	}

	// Generate Kotlin file
	var kotlinCode string
	if len(schema.Events) > 0 {
		kotlinCode = generateKotlinEventsFile(schema.Events)
	} else if len(schema.Routes) > 0 {
		kotlinCode = generateKotlinRoutesFile(schema.Routes)
	} else {
		kotlinCode = generateKotlinFile(schema.Types)
	}

	// Write to file
	if err := os.WriteFile(outputFile, []byte(kotlinCode), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing Kotlin file: %v\n", err)
		os.Exit(1)
	}

	if len(schema.Events) > 0 {
		fmt.Printf("Generated Kotlin events: %s\n", outputFile)
	} else if len(schema.Routes) > 0 {
		fmt.Printf("Generated Kotlin routes: %s\n", outputFile)
	} else {
		fmt.Printf("Generated Kotlin models: %s\n", outputFile)
	}
}

func generateKotlinFile(types map[string]TypeDefinition) string {
	var builder strings.Builder

	// File header
	builder.WriteString("package com.tomyedwab.yellowstone.generated\n\n")
	builder.WriteString("import com.google.gson.annotations.SerializedName\n\n")
	// TODO(tom) STOPSHIP this should not be hard-coded
	builder.WriteString("// Auto-generated from backend/tasks/schema/types.yml\n")
	builder.WriteString("// Do not edit this file directly\n\n")

	// Generate data classes for each type (sorted for deterministic order)
	var typeNames []string
	for typeName := range types {
		typeNames = append(typeNames, typeName)
	}
	sort.Strings(typeNames)

	for _, typeName := range typeNames {
		typeDef := types[typeName]
		builder.WriteString(generateKotlinDataClass(typeName, typeDef))
		builder.WriteString("\n")
	}

	return builder.String()
}

func generateKotlinDataClass(className string, classDef TypeDefinition) string {
	var builder strings.Builder

	// Add description as comment if present
	if classDef.Description != "" {
		builder.WriteString("/**\n")
		builder.WriteString(fmt.Sprintf(" * %s\n", classDef.Description))
		builder.WriteString(" */\n")
	}

	// Start data class definition
	builder.WriteString(fmt.Sprintf("data class %s(\n", className))

	// Generate properties (sorted for deterministic order)
	var propNames []string
	for propName := range classDef.Properties {
		propNames = append(propNames, propName)
	}
	sort.Strings(propNames)

	var propLines []string
	for _, propName := range propNames {
		propDef := classDef.Properties[propName]
		kotlinType := kotlinTypeFromSchema(propDef.Type, propDef.ItemType, propDef.Nullable)
		kotlinPropName := toCamelCase(propName)

		// Add property line with SerializedName annotation
		propLine := fmt.Sprintf("    @SerializedName(\"%s\") val %s: %s", propName, kotlinPropName, kotlinType)
		propLines = append(propLines, propLine)
	}

	// Join properties with commas
	builder.WriteString(strings.Join(propLines, ",\n"))
	builder.WriteString("\n)")

	return builder.String()
}

func kotlinTypeFromSchema(typeName, itemType string, nullable bool) string {
	var baseType string

	switch typeName {
	case "integer":
		baseType = "Int"
	case "string":
		baseType = "String"
	case "boolean":
		baseType = "Boolean"
	case "timestamp":
		baseType = "String" // Using String for timestamps, can be changed to Date/LocalDateTime if needed
	case "array":
		if itemType != "" {
			// Convert itemType to Kotlin equivalent
			kotlinItemType := kotlinTypeFromSchema(itemType, "", false)
			baseType = fmt.Sprintf("List<%s>", kotlinItemType)
		} else {
			baseType = "List<Any>"
		}
	default:
		baseType = typeName
	}

	if nullable {
		return baseType + "?"
	}
	return baseType
}

func toCamelCase(str string) string {
	if len(str) <= 1 {
		return strings.ToLower(str)
	}
	return strings.ToLower(str[:1]) + str[1:]
}

func generateKotlinEventsFile(events map[string]TypeDefinition) string {
	var builder strings.Builder

	// File header
	builder.WriteString("package com.tomyedwab.yellowstone.generated\n\n")
	builder.WriteString("import com.tomyedwab.yellowstone.provider.connection.ConnectionAction\n")
	builder.WriteString("import com.tomyedwab.yellowstone.provider.connection.ConnectionStateProvider\n")
	builder.WriteString("import com.tomyedwab.yellowstone.provider.connection.PendingEvent\n")
	builder.WriteString("import java.text.SimpleDateFormat\n")
	builder.WriteString("import java.util.*\n")
	builder.WriteString("import java.util.UUID\n\n")
	// TODO(tom) STOPSHIP this should not be hard-coded
	builder.WriteString("// Auto-generated from backend/tasks/schema/events.yml\n")
	builder.WriteString("// Do not edit this file directly\n\n")

	// Generate events class
	builder.WriteString("class Events(\n")
	builder.WriteString("    private val connectionStateProvider: ConnectionStateProvider\n")
	builder.WriteString(") {\n\n")

	// Generate function for each event (sorted for deterministic order)
	var eventNames []string
	for eventName := range events {
		eventNames = append(eventNames, eventName)
	}
	sort.Strings(eventNames)

	for _, eventName := range eventNames {
		eventDef := events[eventName]
		builder.WriteString(generateEventFunction(eventName, eventDef))
		builder.WriteString("\n")
	}

	builder.WriteString("}")

	return builder.String()
}

func generateEventFunction(eventName string, eventDef TypeDefinition) string {
	var builder strings.Builder

	// Add description as comment if present
	if eventDef.Description != "" {
		builder.WriteString("    /**\n")
		builder.WriteString(fmt.Sprintf("     * %s\n", eventDef.Description))
		builder.WriteString("     */\n")
	}

	// Generate function name from event name (e.g., "Task:Add" -> "taskAdd")
	functionName := eventNameToFunctionName(eventName)

	// Start function definition
	builder.WriteString(fmt.Sprintf("    fun %s(", functionName))

	// Generate parameters (sorted for deterministic order)
	var propNames []string
	for propName := range eventDef.Properties {
		propNames = append(propNames, propName)
	}
	sort.Strings(propNames)

	var paramLines []string
	for _, propName := range propNames {
		propDef := eventDef.Properties[propName]
		kotlinType := kotlinTypeFromSchema(propDef.Type, propDef.ItemType, propDef.Nullable)
		kotlinPropName := toCamelCase(propName)
		paramLines = append(paramLines, fmt.Sprintf("%s: %s", kotlinPropName, kotlinType))
	}

	builder.WriteString(strings.Join(paramLines, ", "))
	builder.WriteString(") {\n")

	// Generate function body
	builder.WriteString("        val event = PendingEvent(\n")
	builder.WriteString("            clientId = UUID.randomUUID().toString(),\n")
	builder.WriteString(fmt.Sprintf("            type = \"%s\",\n", eventName))
	builder.WriteString("            timestamp = SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\").apply { timeZone = TimeZone.getTimeZone(\"UTC\") }.format(Date()),\n")
	builder.WriteString("            data = mapOf(\n")

	// Generate data map entries (using same sorted order)
	var dataLines []string
	for _, propName := range propNames {
		kotlinPropName := toCamelCase(propName)
		dataLines = append(dataLines, fmt.Sprintf("                \"%s\" to %s", propName, kotlinPropName))
	}
	builder.WriteString(strings.Join(dataLines, ",\n"))

	builder.WriteString("\n            )\n")
	builder.WriteString("        )\n")
	builder.WriteString("        connectionStateProvider.dispatch(ConnectionAction.PublishEvent(event))\n")
	builder.WriteString("    }")

	return builder.String()
}

func eventNameToFunctionName(eventName string) string {
	// Convert "Task:Add" to "taskAdd", "TaskList:UpdateTitle" to "taskListUpdateTitle"
	parts := strings.Split(eventName, ":")
	if len(parts) != 2 {
		return toCamelCase(eventName)
	}

	prefix := toCamelCase(parts[0])
	suffix := parts[1]
	return prefix + suffix
}

func generateKotlinRoutesFile(routes []RouteDefinition) string {
	var builder strings.Builder

	// File header
	builder.WriteString("package com.tomyedwab.yellowstone.generated\n\n")
	builder.WriteString("import androidx.lifecycle.LiveData\n")
	builder.WriteString("import com.google.gson.reflect.TypeToken\n")
	builder.WriteString("import com.tomyedwab.yellowstone.services.connection.DataViewResult\n")
	builder.WriteString("import com.tomyedwab.yellowstone.services.connection.DataViewService\n")
	builder.WriteString("import com.tomyedwab.yellowstone.provider.connection.HubConnectionState\n\n")
	// TODO(tom) STOPSHIP this should not be hard-coded
	builder.WriteString("// Auto-generated from backend/tasks/schema/api.yml\n")
	builder.WriteString("// Do not edit this file directly\n\n")

	// Generate routes class
	builder.WriteString("class ApiRoutes(\n")
	builder.WriteString("    private val dataViewService: DataViewService,\n")
	builder.WriteString("    private val connectionState: LiveData<HubConnectionState>\n")
	builder.WriteString(") {\n\n")

	// Generate function for each route
	for _, route := range routes {
		builder.WriteString(generateRouteFunction(route))
		builder.WriteString("\n")
	}

	builder.WriteString("}")

	return builder.String()
}

func generateRouteFunction(route RouteDefinition) string {
	var builder strings.Builder

	// Add description as comment if present
	if route.Description != "" {
		builder.WriteString("    /**\n")
		builder.WriteString(fmt.Sprintf("     * %s\n", route.Description))
		builder.WriteString("     */\n")
	}

	// Generate function name from route path (e.g., "/api/task/list" -> "getTaskList")
	functionName := routeToFunctionName(route.Route, route.Method)

	// Start function definition
	builder.WriteString(fmt.Sprintf("    fun %s(", functionName))

	// Generate parameters
	var paramLines []string
	for _, param := range route.Parameters {
		kotlinType := kotlinTypeFromSchema(param.Type, "", !param.Required)
		kotlinParamName := toCamelCase(param.Name)
		paramLines = append(paramLines, fmt.Sprintf("%s: %s", kotlinParamName, kotlinType))
	}

	builder.WriteString(strings.Join(paramLines, ", "))
	builder.WriteString(fmt.Sprintf("): LiveData<DataViewResult<%s>> {\n", route.Returns))

	// Generate function body
	builder.WriteString("        return dataViewService.createDataView(\n")
	builder.WriteString("            connectionState = connectionState,\n")
	builder.WriteString("            componentName = \"tasks\",\n") // TODO(tom) STOPSHIP this should not be hard-coded
	builder.WriteString(fmt.Sprintf("            apiPath = \"%s\",\n", strings.TrimPrefix(route.Route, "/")))

	// Generate apiParams map
	if len(route.Parameters) > 0 {
		builder.WriteString("            apiParams = mapOf(\n")
		var paramMapLines []string
		for _, param := range route.Parameters {
			kotlinParamName := toCamelCase(param.Name)
			// Convert all parameter values to strings
			paramMapLines = append(paramMapLines, fmt.Sprintf("                \"%s\" to %s.toString()", param.Name, kotlinParamName))
		}
		builder.WriteString(strings.Join(paramMapLines, ",\n"))
		builder.WriteString("\n            ),\n")
	} else {
		builder.WriteString("            apiParams = emptyMap(),\n")
	}

	builder.WriteString(fmt.Sprintf("            typeToken = object : TypeToken<%s>() {}\n", route.Returns))
	builder.WriteString("        )\n")
	builder.WriteString("    }")

	return builder.String()
}

func routeToFunctionName(routePath string, method string) string {
	// Convert "/api/task/list" to "getTaskList", "/api/tasklist/todo" to "getTasklistTodo"
	// Remove leading slash and split by "/"
	trimmed := strings.TrimPrefix(routePath, "/")
	parts := strings.Split(trimmed, "/")

	// Skip "api" prefix if present
	if len(parts) > 0 && parts[0] == "api" {
		parts = parts[1:]
	}

	// Join parts with title case (except first part), handling underscores
	var functionParts []string
	for i, part := range parts {
		// Handle underscores in part names
		subParts := strings.Split(part, "_")
		var camelCasePart string
		for j, subPart := range subParts {
			if i == 0 && j == 0 {
				camelCasePart += subPart // First part of first segment stays lowercase
			} else {
				camelCasePart += strings.Title(subPart)
			}
		}
		functionParts = append(functionParts, camelCasePart)
	}

	functionName := strings.Join(functionParts, "")

	// Add method prefix (typically "get" for GET requests)
	prefix := strings.ToLower(method)
	if prefix == "get" {
		return prefix + strings.Title(functionName)
	}

	return prefix + strings.Title(functionName)
}
