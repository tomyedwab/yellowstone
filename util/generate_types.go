package main

import (
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type Property struct {
	Type        string `yaml:"type"`
	ItemType    string `yaml:"itemType"`
	Nullable    bool   `yaml:"nullable"`
	Required    bool   `yaml:"required"`
	Description string `yaml:"description"`
}

type TypeDef struct {
	Description string              `yaml:"description"`
	Properties  map[string]Property `yaml:"properties"`
}

type EventDef struct {
	Description string              `yaml:"description"`
	Properties  map[string]Property `yaml:"properties"`
}

type Parameter struct {
	Name        string `yaml:"name"`
	Type        string `yaml:"type"`
	Required    bool   `yaml:"required"`
	Description string `yaml:"description"`
}

type Route struct {
	Route       string      `yaml:"route"`
	Description string      `yaml:"description"`
	Method      string      `yaml:"method"`
	Parameters  []Parameter `yaml:"parameters"`
	Returns     string      `yaml:"returns"`
}

type TypesSchema struct {
	Types map[string]TypeDef `yaml:"types"`
}

type EventsSchema struct {
	Events map[string]EventDef `yaml:"events"`
}

type APISchema struct {
	Routes []Route `yaml:"routes"`
}

type Config struct {
	TypesFile  string
	EventsFile string
	APIFile    string
	Package    string
	OutputFile string
}

func main() {
	if len(os.Args) < 4 {
		fmt.Fprintf(os.Stderr, "Usage: %s <types.yml> <events.yml> <api.yml> [package] [output_file]\n", os.Args[0])
		os.Exit(1)
	}

	config := Config{
		TypesFile:  os.Args[1],
		EventsFile: os.Args[2],
		APIFile:    os.Args[3],
		Package:    "generated",
		OutputFile: "generated_types.go",
	}

	if len(os.Args) > 4 {
		config.Package = os.Args[4]
	}
	if len(os.Args) > 5 {
		config.OutputFile = os.Args[5]
	}

	generator := &Generator{config: config}
	if err := generator.Generate(); err != nil {
		log.Fatal(err)
	}
}

type Generator struct {
	config       Config
	typesSchema  TypesSchema
	eventsSchema EventsSchema
	apiSchema    APISchema
}

func (g *Generator) Generate() error {
	if err := g.loadSchemas(); err != nil {
		return fmt.Errorf("loading schemas: %w", err)
	}

	output, err := g.generateCode()
	if err != nil {
		return fmt.Errorf("generating code: %w", err)
	}

	// Format the generated Go code
	formatted, err := format.Source([]byte(output))
	if err != nil {
		// If formatting fails, write the unformatted code and warn
		fmt.Fprintf(os.Stderr, "Warning: failed to format generated code: %v\n", err)
		formatted = []byte(output)
	}

	if err := os.WriteFile(g.config.OutputFile, formatted, 0644); err != nil {
		return fmt.Errorf("writing output file: %w", err)
	}

	fmt.Printf("Generated and formatted Go types and resolver interface in %s\n", g.config.OutputFile)
	return nil
}

func (g *Generator) loadSchemas() error {
	// Load types schema
	typesData, err := os.ReadFile(g.config.TypesFile)
	if err != nil {
		return fmt.Errorf("reading types file: %w", err)
	}
	if err := yaml.Unmarshal(typesData, &g.typesSchema); err != nil {
		return fmt.Errorf("parsing types schema: %w", err)
	}

	// Load events schema
	eventsData, err := os.ReadFile(g.config.EventsFile)
	if err != nil {
		return fmt.Errorf("reading events file: %w", err)
	}
	if err := yaml.Unmarshal(eventsData, &g.eventsSchema); err != nil {
		return fmt.Errorf("parsing events schema: %w", err)
	}

	// Load API schema
	apiData, err := os.ReadFile(g.config.APIFile)
	if err != nil {
		return fmt.Errorf("reading API file: %w", err)
	}
	if err := yaml.Unmarshal(apiData, &g.apiSchema); err != nil {
		return fmt.Errorf("parsing API schema: %w", err)
	}

	return nil
}

func (g *Generator) generateCode() (string, error) {
	tmpl := `// Code generated by generate_types.go; DO NOT EDIT.

package {{.Package}}

import (
	"net/http"
	"strconv"
	"time"
	"github.com/jmoiron/sqlx"
	"github.com/tomyedwab/yesterday/applib/database"
	"github.com/tomyedwab/yesterday/applib/httputils"
)

// Generated Types from {{.TypesFile}}

{{range $name, $type := .Types}}
// {{$type.Description}}
type {{$name}} struct {
{{- range $propName, $prop := $type.Properties}}
	{{$propName}} {{GoType $prop}} ` + "`json:\"{{$propName}}\"`" + `{{if $prop.Description}} // {{$prop.Description}}{{end}}
{{- end}}
}
{{end}}

// Generated Event Types from {{.EventsFile}}

{{range $name, $event := .Events}}
// {{$event.Description}}
type {{EventTypeName $name}}Event struct {
{{- range $propName, $prop := $event.Properties}}
	{{$propName}} {{GoType $prop}} ` + "`json:\"{{$propName}}\"`" + `{{if $prop.Description}} // {{$prop.Description}}{{end}}
{{- end}}
}
{{end}}

// Generated Resolver Interface from {{.APIFile}}

type Resolver interface {
{{- range .Routes}}
	{{ResolverMethodName .}} (db *sqlx.DB, {{ResolverParams .}}) ({{.Returns}}, error)
{{- end}}
}

// Generated EventHandler Interface from {{.EventsFile}}

type EventHandler interface {
{{- range $name, $event := .Events}}
	{{EventHandlerMethodName $name}} (tx *sqlx.Tx, event *{{EventTypeName $name}}Event) (bool, error)
{{- end}}
}

// Generated initialization function

func InitHandlers(db *database.Database, resolver Resolver, eventHandler EventHandler) error {
	// Register event handlers
{{- range $name, $event := .Events}}
	database.AddEventHandler(db, "{{$name}}", func(tx *sqlx.Tx, event *{{EventTypeName $name}}Event) (bool, error) {
		return eventHandler.{{EventHandlerMethodName $name}}(tx, event)
	})
{{- end}}

	// Register HTTP routes
{{- range .Routes}}
	http.HandleFunc("{{.Route}}", func(w http.ResponseWriter, r *http.Request) {
{{- range .Parameters}}
		{{.Name}}Str := r.URL.Query().Get("{{.Name}}")
{{- if .Required}}
		if {{.Name}}Str == "" {
			http.Error(w, "Missing {{.Name}} parameter", http.StatusBadRequest)
			return
		}
{{- end}}
{{- if eq .Type "integer"}}
		{{.Name}}, err := strconv.Atoi({{.Name}}Str)
		if err != nil {
			http.Error(w, "Invalid {{.Name}} parameter", http.StatusBadRequest)
			return
		}
{{- end}}
{{- end}}

		resp, err := resolver.{{ResolverMethodName .}}({{ResolverCallParams .}})
		httputils.HandleAPIResponse(w, r, resp, err, http.StatusInternalServerError)
	})
{{- end}}

	return nil
}
`

	funcMap := template.FuncMap{
		"GoType": g.goType,
		"EventTypeName": func(name string) string {
			return strings.ReplaceAll(name, ":", "")
		},
		"ResolverMethodName":     g.resolverMethodName,
		"ResolverParams":         g.resolverParams,
		"EventHandlerMethodName": g.eventHandlerMethodName,
		"ResolverCallParams":     g.resolverCallParams,
	}

	t, err := template.New("code").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return "", err
	}

	data := struct {
		Package    string
		TypesFile  string
		EventsFile string
		APIFile    string
		Types      map[string]TypeDef
		Events     map[string]EventDef
		Routes     []Route
	}{
		Package:    g.config.Package,
		TypesFile:  filepath.Base(g.config.TypesFile),
		EventsFile: filepath.Base(g.config.EventsFile),
		APIFile:    filepath.Base(g.config.APIFile),
		Types:      g.typesSchema.Types,
		Events:     g.eventsSchema.Events,
		Routes:     g.apiSchema.Routes,
	}

	var buf strings.Builder
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

func (g *Generator) goType(prop Property) string {
	var baseType string

	switch prop.Type {
	case "string":
		baseType = "string"
	case "integer":
		baseType = "int"
	case "boolean":
		baseType = "bool"
	case "timestamp":
		baseType = "time.Time"
	case "array":
		if prop.ItemType != "" {
			baseType = "[]" + g.resolveType(prop.ItemType)
		} else {
			baseType = "[]interface{}"
		}
	default:
		baseType = g.resolveType(prop.Type)
	}

	if prop.Nullable {
		return "*" + baseType
	}
	return baseType
}

func (g *Generator) resolveType(typeName string) string {
	// Map common types
	switch typeName {
	case "integer":
		return "int"
	case "string":
		return "string"
	case "boolean":
		return "bool"
	case "timestamp":
		return "time.Time"
	}

	// Check if it's a custom type from our schema
	if _, exists := g.typesSchema.Types[typeName]; exists {
		return typeName
	}

	// Default to the type name as-is
	return typeName
}

func (g *Generator) resolverMethodName(route Route) string {
	// Convert route path to method name, mapping closely to the actual route
	// e.g., "/api/task/list" -> "GetApiTaskList"
	// e.g., "/api/task/get" -> "GetApiTaskGet"
	// e.g., "/api/tasklist/all" -> "GetApiTasklistAll"

	parts := strings.Split(strings.Trim(route.Route, "/"), "/")
	var methodParts []string

	// Add HTTP method prefix
	switch strings.ToUpper(route.Method) {
	case "GET":
		methodParts = append(methodParts, "Get")
	case "POST":
		methodParts = append(methodParts, "Create")
	case "PUT":
		methodParts = append(methodParts, "Update")
	case "DELETE":
		methodParts = append(methodParts, "Delete")
	default:
		methodParts = append(methodParts, strings.Title(strings.ToLower(route.Method)))
	}

	// Include all path parts, capitalizing each
	for _, part := range parts {
		methodParts = append(methodParts, strings.Title(part))
	}

	return strings.Join(methodParts, "")
}

func (g *Generator) eventHandlerMethodName(eventName string) string {
	// Convert event name to handler method name
	// e.g., "Task:Add" -> "HandleTaskAddEvent"
	// e.g., "TaskList:UpdateTitle" -> "HandleTaskListUpdateTitleEvent"

	// Remove colons and split on them
	parts := strings.Split(eventName, ":")
	var methodParts []string

	methodParts = append(methodParts, "Handle")

	// Add all parts
	for _, part := range parts {
		methodParts = append(methodParts, strings.Title(part))
	}

	methodParts = append(methodParts, "Event")

	return strings.Join(methodParts, "")
}

func (g *Generator) resolverCallParams(route Route) string {
	var params []string
	// First parameter is always the database
	params = append(params, "db.GetDB()")

	if len(route.Parameters) == 0 {
		return strings.Join(params, ", ")
	}

	// Sort parameters to ensure consistent ordering
	sortedParams := make([]Parameter, len(route.Parameters))
	copy(sortedParams, route.Parameters)
	sort.Slice(sortedParams, func(i, j int) bool {
		return sortedParams[i].Name < sortedParams[j].Name
	})

	for _, param := range sortedParams {
		params = append(params, param.Name)
	}

	return strings.Join(params, ", ")
}

func (g *Generator) resolverParams(route Route) string {
	if len(route.Parameters) == 0 {
		return ""
	}

	var params []string

	// Sort parameters to ensure consistent ordering
	sortedParams := make([]Parameter, len(route.Parameters))
	copy(sortedParams, route.Parameters)
	sort.Slice(sortedParams, func(i, j int) bool {
		return sortedParams[i].Name < sortedParams[j].Name
	})

	for _, param := range sortedParams {
		paramType := g.goType(Property{
			Type:     param.Type,
			Nullable: !param.Required,
		})
		params = append(params, fmt.Sprintf("%s %s", param.Name, paramType))
	}

	return strings.Join(params, ", ")
}
